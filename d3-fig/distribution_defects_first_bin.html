<!DOCTYPE html>
<meta charset="utf-8">
<style>
    .range-label{
        font-size: 14px;
        color: "#7f7f7f";
        font-family: 'Fira Code', monospace;
    }

    .range-select{
        font-size: 10px;
        color: "#7f7f7f";
        font-family: 'Fira Code', monospace;
    }

</style>
<script src="js/plotly.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300&display=swap" rel="stylesheet">
<body>
    <div class="distribution" data-num="0">
        <div class="plot" id="myplot"></div>
        <div class="select">
            <span class="range-label">Range: </span><select class="range-select"></select>
        </div>
        </div>
    </div>
</body>
<script>
    const range = (function(limit, step) {
        let result = []
        for(let i = 0; i < limit; i += step) {
           result = result.concat(
               [{
                   'min': i,
                   'max': i + step - 1,
                   'name': "[" + i.toString() + " - " + (i + step - 1).toString() + "]"
               }]);
        }
        return result
    })(6500, 500);
    Plotly.d3.csv("original_defects.csv", function(err, rows) {

        function unpack(rows, key) {
            return rows.map(function(row) {return row[key]; });
        }

        function unpack_sum(rows, key) {
            let result = Object.values(groupBy(rows, 'project')).map(function(row) {
                return row.map(function(project_row) {
                    return project_row[key]
                        }).reduce(function (a, b) {
                            return parseInt(a) + parseInt(b);
                }, 0);
            });
            return result;
        }

        const groupBy = (rows, key) => {
            // Return the end result
            return rows.reduce((result, row) => {
                // If an array already present for key, push it to the array. Else create an array and push the object
                (result[row[key]] = result[row[key]] || []).push(
                    row
                );
                // Return the current iteration `result` value, this will be taken as next iteration `result` value and accumulate
                return result;
            }, {}); // empty object is the initial value for result object
        };

        setHistogramPlot(0, 499);
        function setHistogramPlot(min, max) {
            let histogram_defects = {
                x: unpack_sum(rows, "number_defects").filter(function(row) {
                   if (parseInt(row) >= 0, parseInt(row) <= max)
                       return row;
                }),
                name: "Defects",
                type: 'histogram',
                histnorm: "count",
                marker: {
                    color: "#00b4d8",
                    width: 0.2
                },
                autobinx: false,
                xbins: {
                    start: min,
                    end: max,
                    size: 13
                }
            };

            let data = [histogram_defects];

            let layout = {
                title: "Distribution of Defects within ranges [min - max]",
                barmode: 'overlay',
                bargap: 0.05,
                bargroupgap: 0.2,
                font: {
                        family: "'Fira Code', monospace",
                        size: 8,
                        color: "#7f7f7f"
                },
                xaxis: {
                    title: "Defects"
                }
            };

            Plotly.newPlot('myplot', data, layout);
        }


        let innerContainer = document.querySelector('[data-num="0"'),
            rangeSelector = innerContainer.querySelector('.range-select')

        function assignOptions(options, selector) {
            for(let i = 0; i < options.length; i++) {
                let currentOption = document.createElement('option');
                currentOption.text = options[i];
                selector.appendChild(currentOption);
            }
        }

        assignOptions(unpack(range, 'name'), rangeSelector);

        function updateData() {
            const interval = range.filter(function(value) {
                if (value['name'] === rangeSelector.value) {
                    return value;
                }
            })[0];
            const min = interval['min'];
            const max = interval['max'];
            setHistogramPlot(min, max);
        }
        rangeSelector.addEventListener('change', updateData, false);

    });
</script>